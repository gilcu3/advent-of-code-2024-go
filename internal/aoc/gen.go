package aoc

import (
	"errors"
	"fmt"
	"os"
	"regexp"
	"strconv"
	"strings"

	"github.com/dolmen-go/codegen"
	"github.com/sirupsen/logrus"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

const yearsFile = "./internal/aoc/years.go"

var validPuzzleFile = regexp.MustCompile(`^day[0-3][0-9]$`)

func puzzlePath(year int) string {
	return fmt.Sprintf("./internal/aoc/year%d", year)
}

func puzzleFileName(year, day int) string {
	path := puzzlePath(year)
	return fmt.Sprintf("%s/day%s.go", path, FormatDay(day))
}

func puzzleInputPath(year int) string {
	return fmt.Sprintf("./internal/aoc/year%d/inputs", year)
}

func puzzleInputFileName(year, day int) string {
	path := puzzleInputPath(year)
	return fmt.Sprintf("%s/%d.txt", path, day)
}

// Generate yearXXXX directory if not exists
func newYearPkgDirectory(year int) {
	path := puzzlePath(year)
	if err := CreateDirectory(path); err != nil {
		logrus.Fatal(err)
	}
}

const puzzleTemplate = `// Code generated by aocgen; DO NOT EDIT.
	package aoc

	type Day{{.Day}} struct{}
	
	func (p Day{{.Day}}) PartA(lines []string) any {
		return nil
	}
	
	func (p Day{{.Day}}) PartB(lines []string) any {
		return nil
	}
	
`

func NewPuzzleFile(year, day int) {
	fileName := puzzleFileName(year, day)
	if _, err := os.Stat(fileName); err == nil || !errors.Is(err, os.ErrNotExist) {
		logrus.Infof("Puzzle file already exists: %s", fileName)
		return
	}

	tmpl := codegen.MustParse(puzzleTemplate)
	if err := tmpl.CreateFile(fileName, map[string]any{
		"Year": year,
		"Day":  FormatDay(day),
	}); err != nil {
		logrus.Fatal(err)
	}

	RemoveFirstLine(fileName)

	logrus.Infof("Created file: %s", fileName)
}

const initPkgTemplate = `// Code generated by aocgen; DO NOT EDIT.
	package aoc

	import (
		"aocgen/internal/aoc"
	)

	func Init() {
		aoc.Register({{.Year}}, map[int]aoc.Puzzle{
			{{.Puzzles}}
		})
	}
`

// Scan directory and autoload all structs in package Init func
func InitializePackage(year int) {
	path := fmt.Sprintf("./internal/aoc/year%d", year)
	fileName := fmt.Sprintf("%s/year%d.go", path, year)
	puzzles := ""

	newYearPkgDirectory(year)
	files, err := os.ReadDir(path)
	if err != nil {
		logrus.Fatal(err)
	}

	for _, file := range files {
		if file.IsDir() {
			continue
		}
		puzzleName := strings.Split(file.Name(), ".")[0]
		if !validPuzzleFile.Match([]byte(puzzleName)) {
			continue
		}
		day, _ := strconv.Atoi(puzzleName[3:])
		correctPuzzleName := cases.Title(language.English).String(cases.Lower(language.English).String(puzzleName))
		puzzles += fmt.Sprintf("%d: %s{},\n", day, correctPuzzleName)
		logrus.Debugf("Found puzzle file for %d-%d", year, day)
	}

	tmpl := codegen.MustParse(initPkgTemplate)
	if err := tmpl.CreateFile(fileName, map[string]interface{}{
		"Year":    year,
		"Puzzles": puzzles,
	}); err != nil {
		logrus.Fatal(err)
	}

	logrus.Infof("Created init file for package: %s", fileName)
}

const initMainTemplate = `// Code generated by aocgen; DO NOT EDIT.
	package aoc

	import (
		{{.Imports}}
	)

	func RegisterYears() {
		{{.Inits}}
	}
`

// InitializeYearsPackage scans directory and autoload all structs in main to call all Init funcs
func InitializeYearsPackages() {
	path := "./internal/"

	err := os.Remove(yearsFile)
	if err != nil {
		logrus.Fatal(err)
	}
	logrus.Infof("Deleted file: %s", yearsFile)

	var imports, inits string

	dirs, err := os.ReadDir(path)
	if err != nil {
		logrus.Fatal(err)
	}

	for _, dir := range dirs {
		if !dir.IsDir() || len(dir.Name()) < 8 || dir.Name()[:4] != "year" {
			logrus.Infof("Skipping directory for package: %s", dir.Name())
			continue
		}
		year, _ := strconv.Atoi(dir.Name()[4:])
		logrus.Infof("Found directory to include in codegen: %d", year)

		imports += fmt.Sprintf("\"aocgen/internal/aoc/year%d\"\n", year)
		inits += fmt.Sprintf("year%d.Init()\n", year)
	}

	tmpl := codegen.MustParse(initMainTemplate)
	if err := tmpl.CreateFile(yearsFile, map[string]interface{}{
		"Imports": imports,
		"Inits":   inits,
	}); err != nil {
		logrus.Fatal(err)
	}
}

const benchmarkingTemplate = `// Code generated by aocgen; DO NOT EDIT.
	package aoc

	import (
		"testing"

		"aocgen/internal/aoc"
	)

	{{.Benchmarks}}
`

func NewBenchmarks(year int) {
	path := fmt.Sprintf("./internal/aoc/year%d", year)
	fileName := fmt.Sprintf("%s/year%d_test.go", path, year)

	benchmarks := ""

	files, err := os.ReadDir(path)
	if err != nil {
		logrus.Fatal(err)
	}

	for _, file := range files {
		if file.IsDir() {
			continue
		}
		puzzleName := strings.Split(file.Name(), ".")[0]
		if !validPuzzleFile.Match([]byte(puzzleName)) {
			continue
		}
		day, _ := strconv.Atoi(puzzleName[3:])
		benchmarks += fmt.Sprintf(`func Benchmark%d%s(b *testing.B) {
			Init()
			input := aoc.Input(%d, %d)
				p := aoc.NewPuzzle(%d, %d)
				if p.PartA(input) != nil {
					b.Run("PartA", func(b *testing.B) {
						b.ResetTimer()
						for i := 0; i < b.N; i++ {
							p.PartA(input)
						}
					})
				}
				if p.PartB(input) != nil {
					b.Run("PartB", func(b *testing.B) {
						b.ResetTimer()
						for i := 0; i < b.N; i++ {
							p.PartB(input)
						}
					})
				}
				
		}
		`, year, FormatDay(day), year, day, year, day)
	}

	tmpl := codegen.MustParse(benchmarkingTemplate)
	if err := tmpl.CreateFile(fileName, map[string]interface{}{
		"Year":       year,
		"Benchmarks": benchmarks,
	}); err != nil {
		logrus.Fatal(err)
	}

	logrus.Infof("Created file: %s", fileName)
}

func RemovePuzzle(year, day int) {
	fileName := puzzleFileName(year, day)
	err := os.Remove(fileName)
	if err != nil {
		logrus.Error(err)
		return
	}
	logrus.Info(fmt.Sprintf("File deleted: %s", fileName))

	InitializeYearsPackages()
	InitializePackage(year)
}

func RemovePuzzleInput(year, day int) {
	fileName := puzzleInputFileName(year, day)
	err := os.Remove(fileName)
	if err != nil {
		logrus.Error(err)
		return
	}
	logrus.Info(fmt.Sprintf("File deleted: %s", fileName))

	InitializeYearsPackages()
	InitializePackage(year)
	NewBenchmarks(year)
}

// FormatDay zero pads single-digit days
func FormatDay(year int) string {
	yearStr := strconv.Itoa(year)
	if len(yearStr) == 1 {
		return "0" + yearStr
	}
	return yearStr
}
